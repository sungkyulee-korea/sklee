name: Security AI Scan (OpenAI + semgrep + debug)

on:
  push:
    branches: ['**']
  pull_request:
    types: [opened, synchronize, reopened]
  workflow_dispatch:

permissions:
  contents: read
  issues: write
  pull-requests: write

env:
  MAX_DIFF_CHARS: "90000"
  SKIP_LARGE_FILES_BYTES: "150000"
  # OpenAI key must be provided via repository secret SKLEE_OPENAI_API_KEY

jobs:
  security-scan:
    runs-on: ubuntu-latest
    env:
      OPENAI_API_KEY: ${{ secrets.SKLEE_OPENAI_API_KEY }}
      MAX_DIFF_CHARS: ${{ env.MAX_DIFF_CHARS }}
      SKIP_LARGE_FILES_BYTES: ${{ env.SKIP_LARGE_FILES_BYTES }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python 3.10
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install semgrep and requests
        run: |
          python -m pip install --upgrade pip
          pip install semgrep requests

      - name: Run semgrep (builtin rules)
        run: |
          semgrep --config p/ci --json --output semgrep-results.json || true
          echo "semgrep builtin done -> semgrep-results.json"

      - name: Run semgrep (repo .semgrep rules if present)
        run: |
          if [ -d ".semgrep" ] || [ -f ".semgrep.yml" ] || [ -f ".semgrep" ]; then
            # try local config
            if [ -f .semgrep.yml ]; then
              semgrep --config .semgrep.yml --json --output semgrep-custom.json || true
              echo "semgrep custom (.semgrep.yml) -> semgrep-custom.json"
            elif [ -d .semgrep ]; then
              semgrep --config .semgrep --json --output semgrep-custom.json || true
              echo "semgrep custom (.semgrep dir) -> semgrep-custom.json"
            else
              echo "no custom semgrep config file/directory"
            fi
          else
            echo "no .semgrep config present"
          fi

      - name: Run external security script (if present)
        run: |
          echo "Listing .github/scripts"
          ls -la .github/scripts || true

          if [ -f .github/scripts/security_scan.py ]; then
            echo "Running .github/scripts/security_scan.py"
            python .github/scripts/security_scan.py || true
            echo "external script done"
          else
            echo "no .github/scripts/security_scan.py - nothing to run"
          fi

      - name: Call OpenAI and post report (semgrep + files -> OpenAI -> post comment/issue)
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            // READ semgrep results (if present)
            let semgrepResults = [];
            const candFiles = ['semgrep-custom.json','semgrep-results.json'];
            for (const f of candFiles) {
              if (fs.existsSync(f)) {
                try {
                  const j = JSON.parse(fs.readFileSync(f,'utf8'));
                  if (Array.isArray(j.results)) semgrepResults = semgrepResults.concat(j.results);
                } catch (e) {}
              }
            }

            // Pick candidate files to show to OpenAI
            const filesSet = new Set();
            for (const r of semgrepResults) {
              const p = r.path || (r.extra && r.extra.metadata && r.extra.metadata.file);
              if (p) filesSet.add(p);
            }

            if (filesSet.size === 0) {
              // try find CWE*bad.java files first or some .java files (limit)
              function scanDir(dir, limit = 8) {
                try {
                  const entries = fs.readdirSync(dir, { withFileTypes: true });
                  for (const e of entries) {
                    const full = path.join(dir, e.name);
                    if (e.isDirectory()) {
                      if (['.git','node_modules','build','dist'].includes(e.name)) continue;
                      scanDir(full, limit);
                      if (filesSet.size >= limit) return;
                    } else if (e.isFile()) {
                      if (/CWE.*_bad\.java$/i.test(e.name) || e.name.endsWith('.java')) {
                        filesSet.add(path.relative(process.cwd(), full));
                        if (filesSet.size >= limit) return;
                      }
                    }
                  }
                } catch (e) {}
              }
              scanDir(process.cwd(), 8);
            }

            // limit files
            const chosenFiles = Array.from(filesSet).slice(0, 8);

            // read content with size limit
            const perFiles = [];
            const maxChars = parseInt(process.env.MAX_DIFF_CHARS || '90000', 10);
            for (const fname of chosenFiles) {
              try {
                const st = fs.statSync(fname);
                if (st.size > parseInt(process.env.SKIP_LARGE_FILES_BYTES || '150000',10)) continue;
                const raw = fs.readFileSync(fname,'utf8');
                const perLimit = Math.max(1000, Math.floor(maxChars / Math.max(1, chosenFiles.length)));
                perFiles.push({ filename: fname, content: raw.slice(0, perLimit) });
              } catch (e) {}
            }

            // semgrep summary text
            let semgrepSummary = '';
            if (semgrepResults.length > 0) {
              semgrepSummary += `Semgrep findings (${semgrepResults.length}):\n`;
              for (const r of semgrepResults.slice(0,50)) {
                const p = r.path || (r.extra && r.extra.metadata && r.extra.metadata.file) || 'unknown';
                const line = (r.start && r.start.line) ? r.start.line : '-';
                const msg = (r.extra && r.extra.message) ? r.extra.message : (r.message || '');
                semgrepSummary += `- ${p}:${line} - ${msg}\n`;
              }
            } else {
              semgrepSummary = 'No semgrep findings (or semgrep JSON missing).';
            }

            // build prompt (Korean)
            const system = "You are a concise security-focused code reviewer. Provide structured JSON then a Korean markdown report.";
            let user = "다음 정보를 보안 관점에서 점검하세요. 응답 형식: JSON 먼저, 그 다음 한글 마크다운 보고서.\n";
            user += "JSON 필드: { overall: 'Block'|'Manual review'|'Low', items: [{file,line,severity,title,cwe,owasp,description,one_line_fix}], summary_kr }\n\n";
            user += "SEMgrep SUMMARY:\n" + semgrepSummary + "\n\n";
            user += "FILES:\n";
            for (const f of perFiles) {
              user += `--- FILE: ${f.filename} ---\n${f.content}\n\n`;
            }
            user += "\n주의: 취약점이 확실하면 overall을 'Block'으로 하며, 관련 CWE/OWASP 분류를 포함하세요. 탐지가 애매하면 'Manual review'로 표기하고 이유를 설명하세요.\n";

            // prepare openai request
            const apiKey = process.env.OPENAI_API_KEY || '';
            if (!apiKey) {
              fs.writeFileSync('ai_report_openai.md', '# ERROR: OPENAI_API_KEY not set\n', 'utf8');
              return;
            }

            const body = {
              model: "gpt-4o-mini",
              messages: [
                { role: "system", content: system },
                { role: "user", content: user }
              ],
              temperature: 0,
              max_tokens: 1500
            };

            // call OpenAI
            try {
              const resp = await fetch("https://api.openai.com/v1/chat/completions", {
                method: "POST",
                headers: {
                  "Authorization": `Bearer ${apiKey}`,
                  "Content-Type": "application/json"
                },
                body: JSON.stringify(body)
              });

              const text = await resp.text();
              if (!resp.ok) {
                fs.writeFileSync('ai_report_openai.md', `# OpenAI Error (status ${resp.status})\n\n${text}`, 'utf8');
              } else {
                const j = JSON.parse(text);
                const content = j.choices && j.choices[0] && j.choices[0].message && j.choices[0].message.content
                  ? j.choices[0].message.content
                  : JSON.stringify(j, null, 2);
                fs.writeFileSync('ai_summary.txt', content, 'utf8');

                // try extract first JSON object
                let jsonObj = null;
                try {
                  const m = content.match(/\{[\s\S]*\}/);
                  if (m) jsonObj = JSON.parse(m[0]);
                } catch (e) { jsonObj = null; }

                if (jsonObj) {
                  let md = "### AI Security Review (자동)\n\n";
                  md += `**전체 판단:** ${jsonObj.overall || 'Manual review'}\n\n`;
                  if (Array.isArray(jsonObj.items) && jsonObj.items.length) {
                    md += "### 발견 항목\n";
                    for (const it of jsonObj.items) {
                      md += `- ${it.file || '-'}:${it.line || '-'} (${it.severity || '-'}) — ${it.title || '-'}\n`;
                      md += `  - CWE: ${it.cwe || '-'}; OWASP: ${it.owasp || '-'}\n`;
                      md += `  - 한줄수정: ${it.one_line_fix || '-'}\n`;
                    }
                    md += "\n";
                  } else {
                    md += "- 취약점 항목 없음(자동 판정)\n\n";
                  }
                  md += "### 권고\n";
                  md += (jsonObj.summary_kr || '자동 요약 없음') + "\n";
                  fs.writeFileSync('ai_report_openai.md', md, 'utf8');
                  fs.writeFileSync('ai_summary_structured.json', JSON.stringify(jsonObj, null, 2), 'utf8');
                } else {
                  // raw output as fallback
                  fs.writeFileSync('ai_report_openai.md', "# AI Review (raw)\n\n" + content, 'utf8');
                }
              }
            } catch (e) {
              fs.writeFileSync('ai_report_openai.md', '# OpenAI fetch failed\n\n' + String(e), 'utf8');
            }

            // Now post: if PR then comment else create issue
            const reportPath = fs.existsSync('ai_report_openai.md') ? 'ai_report_openai.md' : (fs.existsSync('report.md') ? 'report.md' : null);
            const reportBody = reportPath ? fs.readFileSync(reportPath,'utf8') : 'No report generated';

            const isPR = !!context.payload.pull_request;
            if (isPR) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: `### 🤖 AI Security Review (자동 리포트)\n\n${reportBody}\n\n_자동 생성 — 담당자 검토 필요_`
              });
            } else {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `[AI Security Scan] 자동 리포트 - ${new Date().toISOString().slice(0,10)}`,
                body: `브랜치: ${context.ref}\n\n${reportBody}\n\n_자동 생성 리포트_`
              });
            }
            // done

      - name: Debug: show reports and attempt force-create issue (diagnose)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "=== workspace top ==="
          ls -la | sed -n '1,200p' || true

          echo "=== Check report files ==="
          for f in ai_report_openai.md report.md ai_summary.txt ai_summary_structured.json semgrep-results.json semgrep-custom.json; do
            if [ -f "$f" ]; then
              echo "FOUND: $f size=$(stat -c%s "$f")"
              echo "---- head of $f ----"
              sed -n '1,120p' "$f" || true
              echo "---- end ----"
            else
              echo "MISSING: $f"
            fi
            echo "-----------------------------"
          done

          REPORT_FILE=""
          if [ -f ai_report_openai.md ]; then REPORT_FILE="ai_report_openai.md"; elif [ -f report.md ]; then REPORT_FILE="report.md"; fi

          if [ -z "$REPORT_FILE" ]; then
            echo "No report file to post. Exiting debug step."
            exit 0
          fi

          echo "Attempting to create issue via REST API using GITHUB_TOKEN..."
          BODY=$(sed -n '1,800p' "$REPORT_FILE" | sed 's/"/\\"/g' | awk '{printf "%s\\n",$0}')
          API_URL="https://api.github.com/repos/${GITHUB_REPOSITORY}/issues"
          echo "API_URL=$API_URL"

          RESP=$(curl -sS -w "\n%{http_code}" -X POST \
            -H "Authorization: Bearer ${GITHUB_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            "${API_URL}" \
            -d "{\"title\":\"[DEBUG][AI Security Scan] 자동 리포트 - $(date -I)\",\"body\":\"${BODY}\"}" ) || true

          CODE=$(echo "$RESP" | tail -n1)
          BODYR=$(echo "$RESP" | sed '$d')
          echo "HTTP_CODE: $CODE"
          echo "RESPONSE_BODY:"
          echo "$BODYR" | sed -n '1,200p'
          if [ "$CODE" -ge 200 ] && [ "$CODE" -lt 300 ]; then
            echo "Force-create issue succeeded."
          else
            echo "Force-create issue failed. See RESPONSE_BODY above for details."
            exit 1
          fi

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: security-scan-artifacts
          path: |
            semgrep-results.json
            semgrep-custom.json
            semgrep-results.json
            report.md
            ai_report_openai.md
            ai_summary.txt
            ai_summary_structured.json
