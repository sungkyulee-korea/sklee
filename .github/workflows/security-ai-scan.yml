name: Security AI Scan (debug + force-post v3)

on:
  workflow_dispatch:
  pull_request:
    types: [opened, synchronize, reopened]
  push:
    branches: ['**']

permissions:
  contents: read
  issues: write
  pull-requests: write

env:
  OPENAI_API_KEY: ${{ secrets.SKLEE_OPENAI_API_KEY }}
  MAX_FILE_BYTES: "150000"
  MAX_FILES_TO_ANALYZE: "200"

jobs:
  security-scan:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python 3.10
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install dependencies (semgrep, requests)
        run: |
          python -m pip install --upgrade pip
          pip install semgrep requests

      - name: Run semgrep (builtin rules)
        run: |
          semgrep --config p/ci --json --output semgrep-results.json || true
          echo "semgrep finished, results saved to semgrep-results.json (if any)"

      - name: Run external security script (if present)
        id: run_script
        run: |
          echo "----- START external security script step -----"
          echo "Listing .github/scripts directory (if present):"
          ls -la .github/scripts || true

          if [ -f .github/scripts/security_scan.py ]; then
            echo "security_scan.py FOUND - running..."
            python .github/scripts/security_scan.py || echo "security_scan.py exited with non-zero"
            echo "security_scan.py finished"
          else
            echo ".github/scripts/security_scan.py not found — relying on semgrep fallback report"
          fi

          if [ -f report.md ]; then
            echo "report.md created; files_count: 1"
          else
            echo "report.md NOT found at root"
          fi

          echo "----- END external security script step -----"

      - name: Debug & Force-post report (show report and post truncated)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const childExec = require('child_process').execSync;

            core.info('=== WORKSPACE PWD ===');
            try { core.info(childExec('pwd').toString()); } catch(e){ core.info(String(e)); }

            core.info('=== LIST ROOT ===');
            try { core.info(childExec('ls -la').toString()); } catch(e){ core.info(String(e)); }

            core.info('=== LIST .github/scripts ===');
            try { core.info(childExec('ls -la .github/scripts || true').toString()); } catch(e){ core.info(String(e)); }

            // If no report.md, try to generate fallback from semgrep-results.json
            if (!fs.existsSync('report.md')) {
              core.info('report.md NOT found - attempting fallback creation from semgrep-results.json');
              if (fs.existsSync('semgrep-results.json')) {
                try {
                  const txt = fs.readFileSync('semgrep-results.json','utf8');
                  const data = JSON.parse(txt || '{}');
                  const results = Array.isArray(data.results) ? data.results : [];
                  let lines = [];
                  lines.push('### 자동 보안 리포트 (fallback from semgrep)');
                  lines.push('');
                  if (results.length > 0) {
                    lines.push('#### Semgrep 발견 항목:');
                    for (let i=0;i<Math.min(200,results.length);i++) {
                      const r = results[i];
                      const path = r.path || (r.extra && r.extra.metadata && r.extra.metadata.file) || '-';
                      const extra = r.extra || {};
                      const msg = extra.message || r.message || '';
                      let start = '-';
                      if (r.start && typeof r.start === 'object') start = r.start.line || '-';
                      else if (r.start) start = String(r.start);
                      const sev = extra.severity || '';
                      lines.push(`- ${path}:${start} [${sev}] ${msg}`);
                    }
                  } else {
                    lines.push('- Semgrep: 문제 없음 (기본 룰).');
                  }
                  lines.push('');
                  lines.push('_자동 리포트 — 담당자 검토 필요_');
                  fs.writeFileSync('report.md', lines.join('\\n'), {encoding:'utf8'});
                  core.info('Fallback report.md created.');
                } catch(e) {
                  core.info('Fallback creation failed: ' + String(e));
                }
              } else {
                core.info('No semgrep-results.json available for fallback.');
              }
            } else {
              core.info('report.md already exists in workspace root.');
            }

            // Show report.md head (for logs)
            if (fs.existsSync('report.md')) {
              const full = fs.readFileSync('report.md','utf8');
              core.info('report.md size (chars): ' + full.length);
              core.info('---- report.md head (first 4000 chars) ----');
              core.info(full.slice(0,4000));
              core.info('---- end head ----');
            } else {
              core.info('report.md STILL NOT found at workspace root after fallback attempts.');
            }

            // Prepare body (truncate if too long)
            let body = fs.existsSync('report.md') ? fs.readFileSync('report.md','utf8') : 'No report generated.';
            if (body.length > 8000) {
              body = body.slice(0,8000) + '\n\n(리포트가 너무 길어 요약본만 게시되었습니다 - 전체는 artifact 참고)';
            }

            // Make API call and print response for diagnostics
            const isPR = !!context.payload.pull_request;
            try {
              if (isPR) {
                const issue_number = context.payload.pull_request.number;
                core.info(`Posting comment to PR #${issue_number}...`);
                const resp = await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number,
                  body: `### 🤖 AI Security Review (자동 요약)\n\n${body}\n\n_자동 생성 — 담당자 검토 필요_`
                });
                core.info('API response status: ' + (resp.status || 'unknown'));
                core.info('API response data (keys): ' + Object.keys(resp.data || {}).join(', '));
                core.info('Posted truncated report as PR comment');
              } else {
                core.info('Creating Issue with report (push context)...');
                const resp = await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: `[AI Security Scan] 자동 리포트 - ${new Date().toISOString().slice(0,10)}`,
                  body: `브랜치: ${context.ref}\n\n${body}\n\n_자동 생성 리포트_`
                });
                core.info('API response status: ' + (resp.status || 'unknown'));
                core.info('API response data (keys): ' + Object.keys(resp.data || {}).join(', '));
                core.info('Created issue with truncated report');
              }
            } catch(e) {
              core.info('API call failed: ' + String(e));
              try { core.info('Error detail: ' + JSON.stringify(e, Object.getOwnPropertyNames(e))); } catch(e2) {}
            }

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: security-scan-artifacts
          path: |
            semgrep-results.json
            report.md
            files_to_analyze.json
            files_content.json
            heuristics.json
            ai_summary_structured.json
