name: Detailed Semgrep Report (stable & simple)

on:
  workflow_dispatch:
  pull_request:
    types: [opened, synchronize, reopened]
  push:
    branches: ['**']

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  semgrep-report:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python 3.10
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install semgrep
        run: |
          python -m pip install --upgrade pip
          pip install semgrep
          semgrep --version

      - name: Run semgrep (builtin rules)
        id: semgrep_run
        run: |
          semgrep --config p/ci --json --output semgrep-results.json || true
          echo "semgrep-ok"

      - name: Create small semgrep custom rules and run (optional)
        run: |
          cat > semgrep-custom.yml <<'EOF'
rules:
  - id: java-sql-concat
    languages: [java]
    message: "Possible SQL injection via string concatenation"
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: |
              Statement st = $X.createStatement();
              st.execute($Q)
          - pattern: |
              Statement st = $X.createStatement();
              st.executeQuery($Q)
  - id: java-xss-sink
    languages: [java]
    message: "Possible XSS sink: response.getWriter().println(...)"
    severity: ERROR
    patterns:
      - pattern: response.getWriter().println($X)
EOF
          semgrep --config ./semgrep-custom.yml --json --output semgrep-custom.json || true
          python - <<'PY'
import json,sys
out={"results":[]}
for f in ("semgrep-results.json","semgrep-custom.json"):
    try:
        j=json.load(open(f))
        if isinstance(j.get("results"), list):
            out["results"].extend(j["results"])
    except Exception:
        pass
json.dump(out, open("semgrep-merged.json","w"), indent=2, ensure_ascii=False)
print("semgrep merged written")
PY

      - name: Determine changed files (PR or Push)
        id: changed_files
        run: |
          # For PR: use GITHUB_EVENT_PATH to get list; otherwise use git diff or all files fallback
          python - <<'PY'
import os,json,subprocess
event_path = os.environ.get('GITHUB_EVENT_PATH')
files = []
if event_path and os.path.exists(event_path):
    ev = json.load(open(event_path,'r',encoding='utf8'))
    pr = ev.get('pull_request')
    if pr and pr.get('number'):
        # try to get files from git diff between PR commits (best-effort)
        try:
            base = ev['pull_request'].get('base',{}).get('sha')
            head = ev['pull_request'].get('head',{}).get('sha')
            if base and head:
                out = subprocess.check_output(['git','diff','--name-only', base, head]).decode('utf8').splitlines()
                files = out
        except Exception:
            pass
if not files:
    # try git diff from before/after in event
    try:
        before = ev.get('before','') if event_path and os.path.exists(event_path) else ''
        after = ev.get('after','') if event_path and os.path.exists(event_path) else os.environ.get('GITHUB_SHA','')
        if before and after and before != after:
            out = subprocess.check_output(['git','diff','--name-only', before, after]).decode('utf8').splitlines()
            files = out
    except Exception:
        pass
if not files:
    try:
        files = subprocess.check_output(['git','ls-files']).decode('utf8').splitlines()
    except Exception:
        files = []
files = [f for f in files if f and len(f.strip())>0]
open('files_to_analyze.txt','w',encoding='utf8').write("\n".join(files))
print("files_count:", len(files))
PY
          echo "::set-output name=files::$(wc -l files_to_analyze.txt | awk '{print $1}')"

      - name: Build semgrep short summary (human readable)
        id: semgrep_summary
        run: |
          python - <<'PY'
import json,sys
try:
    j=json.load(open('semgrep-merged.json','r',encoding='utf8'))
except Exception:
    j={"results":[]}
lines=[]
for r in j.get('results',[]):
    path = r.get('path') or r.get('check_id') or '-'
    start = "-"
    try:
        loc = r.get('start') or r.get('extra',{}).get('start') or {}
        start = loc.get('line') if isinstance(loc,dict) else "-"
    except Exception:
        start="-"
    msg = r.get('extra',{}).get('message') or r.get('message') or ''
    sev = r.get('extra',{}).get('severity') or ''
    lines.append(f"{path}:{start} [{sev}] {msg}")
if not lines:
    out = "Semgrep: 문제 없음 (기본룰 기준)"
else:
    out = "Semgrep 결과 (요약):\n" + "\n".join(lines[:200])
open('semgrep-summary.txt','w',encoding='utf8').write(out)
print("semgrep-summary written")
PY
          echo "::set-output name=summary::semgrep-summary.txt"

      - name: Simple heuristic grep (XSS/SQL patterns) on changed files
        id: heuristics
        run: |
          # patterns can be extended; keep simple to avoid YAML complexity
          PATTERN_FILE=heuristic-patterns.txt
          cat > $PATTERN_FILE <<'PAT'
response.getWriter
getWriter(
println(
.replaceAll(
createStatement
execute(
prepareStatement(
PAT
          # read files_to_analyze.txt and grep
          while read -r f; do
            if [ -f "$f" ]; then
              grep -n -H -E -f $PATTERN_FILE "$f" || true
            fi
          done < files_to_analyze.txt > heuristics.txt || true
          # limit size
          head -n 200 heuristics.txt > heuristics-limited.txt || true
          echo "heuristics produced"
          echo "::set-output name=heuristics::heuristics-limited.txt"

      - name: Build final report (report.md)
        id: build_report
        run: |
          echo "## 자동 보안 리포트" > report.md
          echo "" >> report.md
          echo "### 1) 분석 대상 파일 (상위 200개)" >> report.md
          head -n 200 files_to_analyze.txt | sed 's/^/- /' >> report.md
          echo "" >> report.md
          echo "### 2) Semgrep 요약" >> report.md
          if [ -f semgrep-summary.txt ]; then
            sed 's/^/    /' semgrep-summary.txt >> report.md
          else
            echo "Semgrep 결과 없음" >> report.md
          fi
          echo "" >> report.md
          echo "### 3) 휴리스틱(샘플)" >> report.md
          if [ -f heuristics-limited.txt ]; then
            echo '```' >> report.md
            sed -n '1,200p' heuristics-limited.txt >> report.md
            echo '```' >> report.md
          else
            echo "휴리스틱 결과 없음" >> report.md
          fi
          echo "" >> report.md
          echo "_참고: 이 리포트는 자동분석 결과이며, 치명적(High/Critical) 항목은 담당자 수동검토가 필요합니다._" >> report.md
          echo "report.md created; size:"
          wc -c report.md || true
          echo "::set-output name=report::report.md"

      - name: Post report to PR as comment (only for pull_request events)
        if: github.event_name == 'pull_request'
        uses: peter-evans/create-or-update-comment@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          issue-number: ${{ github.event.pull_request.number }}
          body-file: report.md
          edit-mode: replace

      - name: Upload artifacts (semgrep and heuristics and report)
        uses: actions/upload-artifact@v4
        with:
          name: security-scan-artifacts
          path: |
            semgrep-results.json
            semgrep-custom.json
            semgrep-merged.json
            semgrep-summary.txt
            files_to_analyze.txt
            heuristics-limited.txt
            report.md
