name: Security AI Scan (ChatGPT)

on:
  pull_request:
    types: [opened, synchronize, reopened]
  push:
    branches: ['**']   # í•„ìš”ì‹œ mainë§Œ ['main']

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  ai-security-scan:
    runs-on: ubuntu-latest
    env:
      OPENAI_API_KEY: ${{ secrets.SKLEE_OPENAI_API_KEY }}
      MAX_DIFF_CHARS: 90000

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # ë³€ê²½ íŒŒì¼/DIFF ì¶”ì¶œ
      - name: Get changed files & diff (PR or push)
        id: changed
        uses: actions/github-script@v7
        with:
          script: |
            const isPR = !!context.payload.pull_request;
            let diff = '';
            let files = [];

            if (isPR) {
              const prNumber = context.payload.pull_request.number;
              const list = await github.rest.pulls.listFiles({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                per_page: 100
              });
              files = list.data.map(f => f.filename);

              const diffResp = await github.request(
                "GET /repos/{owner}/{repo}/pulls/{pull_number}",
                {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                  mediaType: { format: "diff" }
                }
              );
              diff = diffResp.data || '';
            } else {
              const before = context.payload.before;
              const after  = context.payload.after;

              if (before && after && before !== '0000000000000000000000000000000000000000') {
                const comp = await github.rest.repos.compareCommits({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  base: before,
                  head: after
                });
                files = (comp.data.files || []).map(f => f.filename);
                diff = (comp.data.files || []).map(f =>
                  `--- ${f.filename}\n${f.patch || '[binary/no patch]'}\n`
                ).join("\n");
              }
            }

            const maxChars = parseInt(process.env.MAX_DIFF_CHARS || '90000', 10);
            if (diff.length > maxChars) diff = diff.slice(0, maxChars) + "\n\n[...diff truncated]";

            core.setOutput("files", files.join("\n"));
            core.setOutput("diff", diff);

      # OpenAI í˜¸ì¶œ â†’ JSON êµ¬ì¡°í™” (CWE, OWASP, ì„¤ëª…, ê¶Œê³  í¬í•¨)
      - name: Generate structured security report (CWE/OWASP)
        id: structured
        uses: actions/github-script@v7
        env:
          OPENAI_API_KEY: ${{ env.OPENAI_API_KEY }}
        with:
          script: |
            const fs = require('fs');
            const files = process.env.FILES || '';
            const diff  = process.env.DIFF  || '';
            const apiKey = process.env.OPENAI_API_KEY || '';

            let structured = { overall: "Unknown", items: [] };

            if (apiKey) {
              const body = {
                model: "gpt-4o-mini",
                messages: [
                  { role: "system", content:
                    "You are a security code reviewer. Summarize vulnerabilities in JSON. " +
                    "Fields: overall, items[{file,line,severity,cwe,owasp,present,details_ko,recommendation_ko}]. " +
                    "overall âˆˆ {Block, Manual review, Low, None}. " +
                    "details_ko = ê°„ë‹¨í•œ í•œêµ­ì–´ ë¬¸ì œ ì„¤ëª…, recommendation_ko = í•œêµ­ì–´ ê¶Œê³  ì¡°ì¹˜." },
                  { role: "user", content: "FILES:\n" + files + "\n\nDIFF:\n" + diff }
                ],
                max_tokens: 900,
                temperature: 0
              };

              try {
                const resp = await fetch("https://api.openai.com/v1/chat/completions", {
                  method: "POST",
                  headers: {
                    "Authorization": `Bearer ${apiKey}`,
                    "Content-Type": "application/json"
                  },
                  body: JSON.stringify(body)
                });
                if (resp.ok) {
                  const j = await resp.json();
                  try { structured = JSON.parse(j.choices[0].message.content); }
                  catch { structured = { overall: "Unknown", note: "JSON parse error" }; }
                }
              } catch (e) {
                structured = { overall: "Unknown", note: "Fetch failed" };
              }
            }

            fs.writeFileSync('ai_summary_structured.json', JSON.stringify(structured,null,2));
            core.setOutput("structured_path", "ai_summary_structured.json");

      # ê²°ê³¼ë¥¼ PR ì½”ë©˜íŠ¸/Issueë¡œ ê²Œì‹œ
      - name: Post structured Korean report
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            let json = { overall: "Unknown", items: [] };
            if (fs.existsSync('ai_summary_structured.json')) {
              try { json = JSON.parse(fs.readFileSync('ai_summary_structured.json','utf8')); }
              catch { json = { overall: "Unknown", items: [], note:"parse error" }; }
            }

            const overallKor = (json.overall==="Block") ? "ì°¨ë‹¨ í•„ìš”" :
                               (json.overall==="Manual review") ? "ìˆ˜ë™ ê²€í†  í•„ìš”" :
                               (json.overall==="Low") ? "ë‚®ìŒ" : "ì·¨ì•½ì  ì—†ìŒ";

            let md = [];
            md.push("### ğŸ¤– AI Security Review (ìë™ ë³´ê³ )");
            md.push("");
            md.push(`**ì „ì²´ íŒë‹¨:** ${overallKor}`);
            md.push("");

            if (!json.items || json.items.length===0) {
              md.push("_ì·¨ì•½ì  ì—†ìŒ (ìë™ ë¶„ì„)_");
            } else {
              md.push("|íŒŒì¼|ë¼ì¸|ì·¨ì•½ì  ì¡´ì¬|ì‹¬ê°ë„|CWE|OWASP|ì„¤ëª…|ê¶Œê³ |");
              md.push("|---|---:|---|---|---|---|---|---|");
              json.items.forEach(it=>{
                md.push(`|${it.file||'-'}|${it.line||'-'}|${it.present?'ìˆìŒ':'ì—†ìŒ'}|${it.severity||'-'}|${it.cwe||'-'}|${it.owasp||'-'}|${it.details_ko||'-'}|${it.recommendation_ko||'-'}|`);
              });
            }

            md.push("");
            md.push("_ìë™ ìƒì„± ë¦¬í¬íŠ¸ â€” ë‹´ë‹¹ì ê²€í†  í•„ìˆ˜_");

            const body = md.join("\n");
            const isPR = !!context.payload.pull_request;

            if (isPR) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body
              });
            } else {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `[AI Security Scan] ìë™ ë¦¬í¬íŠ¸ - ${new Date().toISOString().slice(0,10)}`,
                body
              });
            }
