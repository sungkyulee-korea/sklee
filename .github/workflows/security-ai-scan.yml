name: Security AI Scan (summary -> Issue/PR, full report artifact)

on:
  push:
    branches: ['**']
  pull_request:
    types: [opened, synchronize, reopened]
  workflow_dispatch:

permissions:
  contents: read
  issues: write
  pull-requests: write

env:
  OPENAI_API_KEY: ${{ secrets.SKLEE_OPENAI_API_KEY }}
  MAX_FILE_BYTES: "150000"
  MAX_FILES_TO_ANALYZE: "200"

jobs:
  security-scan:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python 3.10
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install dependencies (semgrep, requests)
        run: |
          python -m pip install --upgrade pip
          pip install semgrep requests

      - name: Run semgrep (builtin rules or local semgrep.yml)
        run: |
          if [ -f .semgrep.yml ]; then
            semgrep --config .semgrep.yml --json --output semgrep-results.json || true
          elif [ -f semgrep.yml ]; then
            semgrep --config semgrep.yml --json --output semgrep-results.json || true
          else
            semgrep --config p/ci --json --output semgrep-results.json || true
          fi
          echo "semgrep finished; semgrep-results.json created if findings exist."

      - name: Run external security script (if present) -> produce report.md
        id: run_external
        run: |
          set -euo pipefail
          echo "Listing .github/scripts:"
          ls -la .github/scripts || true

          if [ -f .github/scripts/security_scan.py ]; then
            echo "Found .github/scripts/security_scan.py -> running it (exit code ignored)"
            python .github/scripts/security_scan.py || true
          else
            echo "No external script found -> generate fallback report.md from semgrep-results.json"
            python - <<'PY'
import json, os, sys
out = 'report.md'
lines = []
try:
    results = []
    if os.path.exists('semgrep-results.json'):
        with open('semgrep-results.json','r',encoding='utf8') as f:
            data = json.load(f)
        results = data.get('results', []) if isinstance(data, dict) else []

    lines.append("### AI Security Review (자동 리포트)")
    lines.append("")
    if results:
        lines.append("## Semgrep 발견 항목:")
        for r in results[:200]:
            path = r.get('path') or r.get('extra', {}).get('metadata', {}).get('file', '-')
            extra = r.get('extra', {})
            msg = extra.get('message') or r.get('message') or ''
            start = '-'
            if isinstance(r.get('start'), dict):
                start = r.get('start').get('line', '-')
            else:
                start = r.get('start', '-')
            sev = extra.get('severity', '')
            lines.append(f"- {path}:{start} [{sev}] {msg}")
    else:
        lines.append("- Semgrep: 문제 없음 (기본 룰).")

    lines.append("")
    lines.append("_자동 리포트 — 담당자 검토 필요_")
    with open(out, 'w', encoding='utf8') as fw:
        fw.write('\n'.join(lines))
    print('report.md created; files_count: 1')
except Exception as e:
    print('Failed to create fallback report:', e)
    sys.exit(0)
PY
          fi

      - name: Create short summary (truncate for Issue/PR body)
        run: |
          set -euo pipefail
          # if report.md exists, take first N lines then truncate characters to limit
          if [ -f report.md ]; then
            head -n 200 report.md > summary_raw.md || true
            python - <<'PY'
txt = open('summary_raw.md','r',encoding='utf8').read()
max_chars = 4000
if len(txt) > max_chars:
    txt = txt[:max_chars] + "\n\n... (요약이 길어 전체 리포트는 artifact에 첨부됨)\n"
open('summary.md','w',encoding='utf8').write(txt)
print("summary.md created, length:", len(txt))
PY
          else
            echo "### AI Security Review (요약)" > summary.md
            echo "" >> summary.md
            echo "- 리포트 없음. semgrep-results.json 또는 외부 스크립트 결과 확인." >> summary.md
          fi
          echo "summary.md contents (head):"
          sed -n '1,120p' summary.md || true

      - name: Post summary (as PR comment or create Issue)  # always run to ensure posting attempt
        if: ${{ always() }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          EVENT_PATH: ${{ github.event_path }}
        run: |
          python - <<'PY'
import os, json, requests
repo = os.environ['REPO']
token = os.environ.get('GITHUB_TOKEN')
event_path = os.environ.get('EVENT_PATH')
headers = {'Authorization': f'token {token}', 'Accept': 'application/vnd.github+json'}
body_text = ''
if os.path.exists('summary.md'):
    body_text = open('summary.md','r',encoding='utf8').read()
else:
    body_text = "(No summary available)"

# attach small note
body_text = "### AI Security Review (요약)\n\n" + body_text + "\n\n(전체 리포트는 artifact로 업로드됩니다)"

# detect PR
is_pr = False
pr_number = None
if event_path and os.path.exists(event_path):
    ev = json.load(open(event_path,'r',encoding='utf8'))
    if 'pull_request' in ev and ev['pull_request'] and 'number' in ev['pull_request']:
        is_pr = True
        pr_number = ev['pull_request']['number']

if is_pr:
    url = f'https://api.github.com/repos/{repo}/issues/{pr_number}/comments'
    payload = {'body': body_text}
    r = requests.post(url, headers=headers, json=payload)
    print('POST PR comment to', url, 'status', r.status_code)
    print(r.text[:2000])
else:
    url = f'https://api.github.com/repos/{repo}/issues'
    title = f"[AI Security Scan] 자동 리포트 - {__import__('datetime').datetime.utcnow().date()}"
    payload = {'title': title, 'body': body_text}
    r = requests.post(url, headers=headers, json=payload)
    print('Created issue via', url, 'status', r.status_code)
    print(r.text[:2000])
PY

      - name: Upload artifacts (full report + extras)
        uses: actions/upload-artifact@v4
        with:
          name: security-scan-artifacts
          path: |
            semgrep-results.json
            report.md
            summary.md

      - name: Done
        run: echo "Security scan job finished."
