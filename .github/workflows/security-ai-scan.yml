name: Security AI Scan (ChatGPT + Semgrep CLI)

on:
  workflow_dispatch:
  pull_request:
    types: [opened, synchronize, reopened]
  push:
    branches: ['**']

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  ai-security-scan:
    runs-on: ubuntu-latest
    env:
      OPENAI_API_KEY: ${{ secrets.SKLEE_OPENAI_API_KEY }}
      MAX_FILE_BYTES: 150000
      MAX_DIFF_CHARS: 90000

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get changed files & diff (PR or push)
        id: changed
        uses: actions/github-script@v7
        with:
          script: |
            const isPR = !!context.payload.pull_request;
            let diff = '';
            let files = [];

            if (isPR) {
              const prNumber = context.payload.pull_request.number;
              const list = await github.rest.pulls.listFiles({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                per_page: 300
              });
              files = list.data.map(f => f.filename);

              const diffResp = await github.request(
                "GET /repos/{owner}/{repo}/pulls/{pull_number}",
                {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                  mediaType: { format: "diff" }
                }
              );
              diff = diffResp.data || '';
            } else {
              const before = context.payload.before;
              const after  = context.payload.after;
              if (before && after && before !== '0000000000000000000000000000000000000000') {
                const comp = await github.rest.repos.compareCommits({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  base: before,
                  head: after
                });
                files = (comp.data.files || []).map(f => f.filename);
                diff = (comp.data.files || []).map(f =>
                  `--- ${f.filename}\n${f.patch || '[binary/no patch]'}\n`
                ).join("\n");
              } else {
                const tree = await github.rest.git.getTree({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  tree_sha: context.sha,
                  recursive: "1"
                }).catch(()=>({data:{tree:[]}}));
                files = (tree.data.tree || []).map(t => t.path).slice(0, 300);
                diff = '';
              }
            }

            const maxChars = parseInt(process.env.MAX_DIFF_CHARS || '90000', 10);
            if (diff.length > maxChars) diff = diff.slice(0, maxChars) + "\n\n[...diff truncated]";

            core.setOutput("files", files.join("\n"));
            core.setOutput("diff", diff);

      - name: Save changed files list
        run: |
          echo "${{ steps.changed.outputs.files }}" > changed_files_list.txt || true
          wc -l changed_files_list.txt || true

      - name: Read changed files contents (truncate large files)
        id: read_files
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const list = fs.existsSync('changed_files_list.txt') ? fs.readFileSync('changed_files_list.txt','utf8').split(/\r?\n/).filter(Boolean) : [];
            const maxBytes = parseInt(process.env.MAX_FILE_BYTES || '150000', 10);
            const out = {};
            for (const f of list) {
              try {
                if (fs.existsSync(f)) {
                  let s = fs.readFileSync(f,'utf8');
                  if (s.length > maxBytes) s = s.slice(0, maxBytes) + "\n\n[...truncated]";
                  out[f] = s;
                } else {
                  out[f] = '[file not checked out or binary]';
                }
              } catch (e) {
                out[f] = '[error reading file]';
              }
            }
            fs.writeFileSync('changed_files_full.json', JSON.stringify(out, null, 2));
            core.setOutput('path','changed_files_full.json');

      - name: Setup Python for semgrep
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install semgrep (pip)
        run: |
          python -m pip install --upgrade pip
          pip install semgrep
          semgrep --version

      - name: Run semgrep (policy-based static scan)
        id: semgrep
        run: |
          semgrep --config p/ci --json --output semgrep-results.json || true
          if [ -f semgrep-results.json ]; then
            echo "Semgrep results saved to semgrep-results.json"
            # jq가 기본으로 설치되어 있으므로 결과 개수 출력
            if command -v jq >/dev/null 2>&1; then
              echo "Findings:" $(jq '.results | length' semgrep-results.json)
            fi
          else
            echo "No semgrep output file found."
          fi
        shell: bash

      - name: Choose files flagged by semgrep (or fallback to changed files)
        id: chosen
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            let flagged = new Set();
            if (fs.existsSync('semgrep-results.json')) {
              try {
                const r = JSON.parse(fs.readFileSync('semgrep-results.json','utf8'));
                (r.results || []).forEach(item => {
                  if (item.path) flagged.add(item.path);
                });
              } catch(e) {}
            }
            if (flagged.size === 0) {
              const list = fs.existsSync('changed_files_list.txt') ? fs.readFileSync('changed_files_list.txt','utf8').split(/\r?\n/).filter(Boolean) : [];
              list.forEach(f => flagged.add(f));
            }
            const arr = Array.from(flagged).slice(0,100);
            fs.writeFileSync('files_to_analyze.json', JSON.stringify(arr, null, 2));
            core.setOutput('path','files_to_analyze.json');
            core.setOutput('count', arr.length.toString());

      - name: Call OpenAI for structured analysis (on files flagged)
        id: call_openai
        uses: actions/github-script@v7
        env:
          OPENAI_API_KEY: ${{ env.OPENAI_API_KEY }}
        with:
          script: |
            const fs = require('fs');
            const apiKey = process.env.OPENAI_API_KEY || '';
            const filesToAnalyze = fs.existsSync('files_to_analyze.json') ? JSON.parse(fs.readFileSync('files_to_analyze.json','utf8')) : [];
            const allFiles = fs.existsSync('changed_files_full.json') ? JSON.parse(fs.readFileSync('changed_files_full.json','utf8')) : {};
            let structured = { overall: "None", items: [] };

            if (!apiKey) {
              fs.writeFileSync('ai_summary_structured.json', JSON.stringify({overall:"Unknown", note:"OPENAI_API_KEY empty"}, null, 2));
              return;
            }
            if (filesToAnalyze.length === 0) {
              fs.writeFileSync('ai_summary_structured.json', JSON.stringify(structured, null, 2));
              return;
            }

            let prompt = "You are a security code reviewer. For each file below, detect true vulnerabilities relevant to CWE and OWASP Top10. ";
            prompt += "Return a JSON object: { overall: 'Block'|'Manual review'|'Low'|'None', items:[{file,line,severity,cwe,owasp,present,details_ko,recommendation_ko}] }. ";
            prompt += "Only include items that are likely true vulnerabilities. Keep details_ko and recommendation_ko concise (1-2 sentences). Do not include raw code except filenames and line numbers.\n\n";

            for (const f of filesToAnalyze) {
              const content = allFiles[f] || '[not available]';
              prompt += `--- ${f} ---\n`;
              prompt += (content.length > 120000 ? content.slice(0,120000) + "\n\n[...truncated]" : content) + "\n\n";
            }

            const body = {
              model: "gpt-4o-mini",
              messages: [
                { role: "system", content: "You are a concise, security-focused code reviewer. Map findings to CWE and OWASP Top10 when possible. Respond with valid JSON only." },
                { role: "user", content: prompt }
              ],
              temperature: 0,
              max_tokens: 1400
            };

            try {
              const resp = await fetch("https://api.openai.com/v1/chat/completions", {
                method: "POST",
                headers: {
                  "Authorization": `Bearer ${apiKey}`,
                  "Content-Type": "application/json"
                },
                body: JSON.stringify(body)
              });

              if (resp.ok) {
                const j = await resp.json();
                const text = j.choices?.[0]?.message?.content || '';
                try {
                  structured = JSON.parse(text);
                } catch (e) {
                  const m = text.match(/\{[\s\S]*\}$/);
                  if (m) {
                    try { structured = JSON.parse(m[0]); } catch(e2) { structured = { overall: "Unknown", note: "parse error" }; }
                  } else {
                    structured = { overall: "Unknown", note: "Model returned non-JSON. Raw: " + text.slice(0,800) };
                  }
                }
              } else {
                const t = await resp.text();
                structured = { overall: "Unknown", note: `[OpenAI error ${resp.status}] ${t.slice(0,800)}` };
              }
            } catch (e) {
              structured = { overall: "Unknown", note: "Fetch failed: " + String(e) };
            }

            fs.writeFileSync('ai_summary_structured.json', JSON.stringify(structured, null, 2));

      - name: Post structured Korean report (PR comment or Issue)
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            let json = { overall: "Unknown", items: [] };
            if (fs.existsSync('ai_summary_structured.json')) {
              try { json = JSON.parse(fs.readFileSync('ai_summary_structured.json','utf8')); }
              catch { json = { overall: "Unknown", items: [], note: "parse error" }; }
            }

            const overallMap = { "Block":"차단 필요", "Manual review":"수동 검토 필요", "Low":"낮음", "None":"취약점 없음" };
            const overallKor = overallMap[json.overall] || json.overall || "알 수 없음";

            let md = [];
            md.push("### 🤖 AI Security Review (자동 보고)");
            md.push("");
            md.push(`**전체 판단:** ${overallKor}`);
            md.push("");

            if (!json.items || json.items.length === 0) {
              md.push("_취약점 없음 (자동 분석)_");
            } else {
              md.push("|파일|라인|취약점|심각도|CWE|OWASP|문제 요약 (한국어)|권고 (한국어)|");
              md.push("|---|---:|---|---|---|---|---|---|");
              json.items.forEach(it=>{
                const file = it.file || '-';
                const line = it.line || '-';
                const present = (it.present===false) ? '아님' : '있음';
                const sev = it.severity || '-';
                const cwe = it.cwe || '-';
                const owasp = it.owasp || '-';
                const desc = (it.details_ko || it.short_desc || '-').replace(/\r?\n/g,' ');
                const rec = (it.recommendation_ko || '-').replace(/\r?\n/g,' ');
                md.push(`|${file}|${line}|${present}|${sev}|${cwe}|${owasp}|${desc}|${rec}|`);
              });
            }

            md.push("");
            md.push("> ※ 자동 도구 결과입니다. '차단 필요' 또는 '치명적' 항목은 담당자가 즉시 수동 검토·조치하세요.");
            md.push("");
            md.push("<details><summary>English original / raw structured JSON</summary>");
            md.push("");
            md.push("```json");
            md.push(fs.existsSync('ai_summary_structured.json') ? fs.readFileSync('ai_summary_structured.json','utf8') : '{}');
            md.push("```");
            md.push("");
            md.push("</details>");
            md.push("");
            md.push("_자동 생성 리포트 — 담당자 검토 필수_");

            const body = md.join("\n");
            const isPR = !!context.payload.pull_request;

            if (isPR) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body
              });
            } else {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `[AI Security Scan] 자동 리포트 - ${new Date().toISOString().slice(0,10)}`,
                body
              });
            }
